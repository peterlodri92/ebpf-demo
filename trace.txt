## Project Structure
```
├── Dockerfile
├── Makefile
├── cmd/
│    └── tracer/
│        └── main.go
├── entrypoint.sh
├── go.mod
├── go.sum
├── pkg/
│    └── bpf/
│        ├── tracer.c
│        └── tracer.h
└── vmlinux.h
```

## vmlinux.h
```

```
____

## entrypoint.sh
```
\#\!/bin/bash
set \-e

echo "Mounting filesystems\.\.\."

\# Mount debugfs
if mountpoint \-q /sys/kernel/debug; then
    echo "debugfs is already mounted"
else
    echo "Mounting debugfs\.\.\."
    mount \-t debugfs none /sys/kernel/debug
    if \[ $? \-eq 0 \]; then
        echo "debugfs mounted successfully"
    else
        echo "Failed to mount debugfs"
        exit 1
    fi
fi

\# Mount tracefs
if mountpoint \-q /sys/kernel/tracing; then
    echo "tracefs is already mounted"
else
    echo "Mounting tracefs\.\.\."
    mount \-t tracefs none /sys/kernel/tracing
    if \[ $? \-eq 0 \]; then
        echo "tracefs mounted successfully"
    else
        echo "Failed to mount tracefs"
        exit 1
    fi
fi

\# Mount bpf filesystem
if mountpoint \-q /sys/fs/bpf; then
    echo "bpf filesystem is already mounted"
else
    echo "Mounting bpf filesystem\.\.\."
    mount \-t bpf none /sys/fs/bpf
    if \[ $? \-eq 0 \]; then
        echo "bpf filesystem mounted successfully"
    else
        echo "Failed to mount bpf filesystem"
        exit 1
    fi
fi

\# Verify mounts and permissions
echo "Verifying mounts and permissions\.\.\."
echo "debugfs mount:"
mount | grep debugfs
ls \-la /sys/kernel/debug
echo
echo "tracefs mount:"
mount | grep tracefs
ls \-la /sys/kernel/tracing
echo
echo "bpf mount:"
mount | grep bpf
ls \-la /sys/fs/bpf
echo
echo "Checking tracing directory:"
ls \-la /sys/kernel/tracing/events/sched/

\# Set kernel\.perf\_event\_paranoid to \-1 to allow perf monitoring
sysctl \-w kernel\.perf\_event\_paranoid=\-1

\# Set kernel\.kptr\_restrict to 0 to allow reading kernel symbols
sysctl \-w kernel\.kptr\_restrict=0

\# Generate vmlinux\.h from host kernel
bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux\.h
cp vmlinux\.h pkg/bpf/

\# Build the tracer with host's kernel headers
make clean
make

\# Update dynamic linker
ldconfig

echo "Starting tracer\.\.\."
exec \./tracer

```
____

## cmd/tracer/main.go
```
package main

import \(
	"bytes"
	"encoding/binary"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github\.com/cilium/ebpf/link"
	"github\.com/cilium/ebpf/perf"
	"github\.com/cilium/ebpf/rlimit"
\)

//go:generate go run github\.com/cilium/ebpf/cmd/bpf2go \-cc clang \-cflags "\-O2 \-g \-Wall \-I/usr/include/x86\_64\-linux\-gnu \-I/usr/include" bpf \.\./\.\./pkg/bpf/tracer\.c \-\- \-I\.\./\.\./pkg/bpf

type Event struct \{
	PID       uint32
	PPID      uint32
	Timestamp uint64
	Comm      \[16\]byte
\}

func main\(\) \{
	if err := rlimit\.RemoveMemlock\(\); err \!= nil \{
		log\.Fatalf\("Failed to remove rlimit: %v", err\)
	\}

	objs := bpfObjects\{\}
	if err := loadBpfObjects\(&objs, nil\); err \!= nil \{
		log\.Fatalf\("Loading objects: %v", err\)
	\}
	defer objs\.Close\(\)

	execTP, err := link\.Tracepoint\("sched", "sched\_process\_exec", objs\.TraceExec, nil\)
	if err \!= nil \{
		log\.Fatalf\("Opening exec tracepoint: %v", err\)
	\}
	defer execTP\.Close\(\)

	exitTP, err := link\.Tracepoint\("sched", "sched\_process\_exit", objs\.TraceExit, nil\)
	if err \!= nil \{
		log\.Fatalf\("Opening exit tracepoint: %v", err\)
	\}
	defer exitTP\.Close\(\)

	rd, err := perf\.NewReader\(objs\.Events, os\.Getpagesize\(\)\)
	if err \!= nil \{
		log\.Fatalf\("Creating perf event reader: %v", err\)
	\}
	defer rd\.Close\(\)

	sig := make\(chan os\.Signal, 1\)
	signal\.Notify\(sig, syscall\.SIGINT, syscall\.SIGTERM\)

	fmt\.Println\("Tracing all processes\.\.\. Hit Ctrl\-C to end\."\)

	go func\(\) \{
		var event Event
		for \{
			record, err := rd\.Read\(\)
			if err \!= nil \{
				if err == perf\.ErrClosed \{
					return
				\}
				log\.Printf\("Reading perf event: %v", err\)
				continue
			\}

			if record\.LostSamples \!= 0 \{
				log\.Printf\("Lost %d samples", record\.LostSamples\)
				continue
			\}

			if err := binary\.Read\(bytes\.NewReader\(record\.RawSample\), binary\.LittleEndian, &event\); err \!= nil \{
				log\.Printf\("Parsing perf event: %v", err\)
				continue
			\}

			timestamp := time\.Unix\(0, int64\(event\.Timestamp\)\)

			comm := make\(\[\]byte, 0, 16\)
			for \_, b := range event\.Comm \{
				if b == 0 \{
					break
				\}
				comm = append\(comm, b\)
			\}

			fmt\.Printf\("\[%s\] PID: %d, PPID: %d, Command: %s\\n",
				timestamp\.Format\(time\.RFC3339\),
				event\.PID,
				event\.PPID,
				string\(comm\),
			\)
		\}
	\}\(\)

	<\-sig
	fmt\.Println\("\\nReceived signal, exiting\.\.\."\)
\}

```
____

## pkg/bpf/tracer.c
```
\#include "tracer\.h"

char LICENSE\[\] SEC\("license"\) = "GPL";

// Maps definition using the macro
BPF\_MAP\(events, BPF\_MAP\_TYPE\_PERF\_EVENT\_ARRAY, int, \_\_u32, 1024\);
BPF\_MAP\(target\_pid\_map, BPF\_MAP\_TYPE\_HASH, \_\_u32, \_\_u32, 1\);

SEC\("tracepoint/sched/sched\_process\_exec"\)
int trace\_exec\(void \*ctx\)
\{
    \_\_u64 pid\_tgid = bpf\_get\_current\_pid\_tgid\(\);
    \_\_u32 pid = pid\_tgid >> 32;

    struct event e = \{\};
    e\.pid = pid;
    e\.timestamp = bpf\_ktime\_get\_ns\(\);

    struct task\_struct \*task = \(struct task\_struct \*\)bpf\_get\_current\_task\(\);
    if \(\!task\)
        return 0;

    struct task\_struct \*parent;
    if \(bpf\_probe\_read\(&parent, sizeof\(parent\), &task\->real\_parent\)\)
        return 0;

    if \(bpf\_probe\_read\(&e\.ppid, sizeof\(e\.ppid\), &parent\->tgid\)\)
        return 0;

    bpf\_get\_current\_comm\(e\.comm, sizeof\(e\.comm\)\);

    // Only emit events for python processes
    if \(e\.comm\[0\] \!= 'p' && e\.comm\[0\] \!= 'u'\) // python/python3 or uvicorn
        return 0;
    if \(e\.comm\[1\] \!= 'y' && e\.comm\[1\] \!= 'v'\) // python/python3 or uvicorn
        return 0;

    bpf\_perf\_event\_output\(ctx, &events, BPF\_F\_CURRENT\_CPU, &e, sizeof\(e\)\);
    return 0;
\}

SEC\("tracepoint/sched/sched\_process\_exit"\)
int trace\_exit\(void \*ctx\)
\{
    \_\_u64 pid\_tgid = bpf\_get\_current\_pid\_tgid\(\);
    \_\_u32 pid = pid\_tgid >> 32;
    \_\_u32 key = 0;

    struct event e = \{\};
    e\.pid = pid;
    e\.timestamp = bpf\_ktime\_get\_ns\(\);

    struct task\_struct \*task = \(struct task\_struct \*\)bpf\_get\_current\_task\(\);
    if \(\!task\)
        return 0;

    struct task\_struct \*parent;
    if \(bpf\_probe\_read\(&parent, sizeof\(parent\), &task\->real\_parent\)\)
        return 0;

    if \(bpf\_probe\_read\(&e\.ppid, sizeof\(e\.ppid\), &parent\->tgid\)\)
        return 0;

    bpf\_get\_current\_comm\(e\.comm, sizeof\(e\.comm\)\);

    // Only emit events for python processes
    if \(e\.comm\[0\] \!= 'p' && e\.comm\[0\] \!= 'u'\) // python/python3 or uvicorn
        return 0;
    if \(e\.comm\[1\] \!= 'y' && e\.comm\[1\] \!= 'v'\) // python/python3 or uvicorn
        return 0;

    bpf\_perf\_event\_output\(ctx, &events, BPF\_F\_CURRENT\_CPU, &e, sizeof\(e\)\);
    return 0;
\}

```
____

## pkg/bpf/tracer.h
```
\#ifndef \_\_TRACER\_H
\#define \_\_TRACER\_H

\#include "vmlinux\.h"
\#include <bpf/bpf\_helpers\.h>
\#include <bpf/bpf\_tracing\.h>
\#include <bpf/bpf\_core\_read\.h>

// Basic type definitions if not already defined
\#ifndef \_\_u8
typedef unsigned char \_\_u8;
\#endif
\#ifndef \_\_u16
typedef unsigned short \_\_u16;
\#endif
\#ifndef \_\_u32
typedef unsigned int \_\_u32;
\#endif
\#ifndef \_\_u64
typedef unsigned long long \_\_u64;
\#endif

// Event structure to pass data to userspace
struct event
\{
    \_\_u32 pid;
    \_\_u32 ppid;
    \_\_u64 timestamp;
    char comm\[16\];
\};

// BPF map definitions
\#define BPF\_MAP\(\_name, \_type, \_key\_type, \_value\_type, \_max\_entries\) \\
    struct                                                          \\
    \{                                                               \\
        \_\_uint\(type, \_type\);                                        \\
        \_\_uint\(max\_entries, \_max\_entries\);                          \\
        \_\_type\(key, \_key\_type\);                                     \\
        \_\_type\(value, \_value\_type\);                                 \\
    \} \_name SEC\("\.maps"\)

\#endif /\* \_\_TRACER\_H \*/
```
____
